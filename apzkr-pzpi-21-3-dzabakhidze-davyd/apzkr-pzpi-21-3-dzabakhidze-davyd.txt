Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА

з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система надання допомоги постраждалим з використанням браслетів з підтримкою NFC

Студент гр. ПЗПІ-21-3 	__________________ Дзабахідзе Д.С.
(підпис)

Керівник роботи 		__________________ доц. Лещинська І.О.
(підпис)
Роботу захищено «__»_________2024 р.
з оцінкою _________________________
Комісія: 				__________________ доц. Лещинська І.О.
(підпис)
__________________ доц. Лещинський В.О.
(підпис)
__________________ ст.викл. Сокорчук І.П.
(підпис)
Харків 
2024 р.
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук                           Кафедра програмної інженерії     
Спеціальність 121 – Інженерія програмного забезпечення                                       
Курс                   3                   Семестр                                  6                                       
Навчальна дисципліна Архітектура програмного забезпечення                              

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

                                            Дзабахідзе Давиду Сослановичу                                           
1. Тема роботи: «Програмна система надання допомоги постраждалим з використанням браслетів з підтримкою NFC» – Kolosok
2. Термін узгодження завдання курсової роботи «19»    лютого     2024 р.
3. Термін здачі студентом закінченої роботи «15»    червня     2024 р.
4. Вихідні дані до проекту (роботи): У програмній системі передбачити: авторизацію, створення нових бригад та додавання туди працівників. Додавання інформації про постраждалого та моніторинг виконаних над постраждалим дійЖ генерації інформацію про постраждалого у вигляді QR-коду; створення резервних копій баз даних; редагування інформацію про працівників бригади, постраждалих, дії; вибір перекладу інтерфейсу українською чи або англійською мовами. Для програмної системи використовуватимуться ОС Windows 10 або 11, систему управління базами даних Microsoft SQL Server 2019, редактор коду Web Storm, середовище розробки Microsoft Visual Studio 2022, мови програмування TypeScript та C#, а також фреймворки ASP.NET Core 8.0 для серверної частини і Angular 16 для клієнтської частини
5. Зміст пояснювальної записки (перелік питань, що належить розробити)
Вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки                                                                                                                          
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень)
Діаграми розгортання, діаграми прецедентів, діаграми пакетів, діаграма компонентів, діаграма взаємодії, діаграма діяльності, ER-модель даних, файлова структура серверної та клієнтської частин проекту, інтерфейс сторінки редагування подій, інтерфейс сторінки управління ресурсами.
КАЛЕНДАРНИЙ ПЛАН

№	Назва етапів курсової роботи	Термін виконання
етапів роботи	Примітка
1	Функціональна специфікація
програмного проекту	29.02.2024	виконано
2	Проектування програмного
проекту	08.03.2024	виконано
3	Кодування програмного проекту	13.05.2024	виконано
4	Оформлення пояснювальної
записки	31.05.2024	виконано
5	Захист курсової роботи	11.06.2024	виконано


Дата видачі завдання «19»       лютого       2024 р.

Керівник 					______________ доц. Лещинська І.О.
(підпис)

Завдання прийняв до виконання
ст.гр. ПЗПІІ-21-3					 _____________ Дзабахідзе Д.С.
(підпис)

РЕФЕРАТ

Пояснювальна записка до курсової роботи: 52 с., 20 рис., 3 табл., 1 додаток, 6 джерел.
ПОСТРАЖДАЛІ, ПРАЦІВНИКИ БРИГАД, БРИГАДИ, QR-КОД, РЕЗЕРВНА КОПІЯ БАЗИ ДАНИХ, УПРАВЛІННЯ КОРИСТУВАЧАМИ, ЛОКАЛІЗАЦІЯ, КЕРУВАННЯ БРИГАДАМИ, БРАСЛЕТ З NFC.
Об’єктом дослідження цієї роботи є система для надання допомоги постраждалим за допомогою браслетів з підтримкою NFC. Сучасні рятувальні та медичні служби стикаються з численними викликами, коли потрібно оперативно надати допомогу та доступ до медичних даних постраждалих. 
Метою роботи є розробка програмної системи для відстеження медичних даних та іншої інформації про постраждалих за допомогою браслетів з підтримкою NFC. Ця система забезпечить швидке та ефективне виявлення постраждалих, а також зв'язок зі службами екстреної допомоги та медичними працівниками. Продукт буде корисним для рятувальників, медичних працівників та інших служб, які надають допомогу постраждалим, дозволяючи швидко виявляти постраждалих та отримувати доступ до необхідної інформації для надання кваліфікованої допомоги.
Методами розробки є платформа .NET 8, фреймворк ASP.NET Core 8.0, ORM Entity Framework Core 8.0 [4], СУБД PostgreSQL, що разом утворюють серверну частину проекту. Для створення клієнтської частини було обрано фреймворк Angular 16. Робота IoT пристрою базується на використанні мікроконтролера ESP32.
У результаті було створено систему, що дозволяє керувати бригадами, членаи бригад, надавати інформацію про дію над постраждалими та додавати інформацію про них. Ця програмна система складається із 3 компонентів: серверної частини, клієнтської частини та ІоТ пристрою.

ЗМІСТ

ВСТУП	8
1 БІЗНЕС-ВИМОГИ	9
1.1 Передумови	9
1.2 Бізнес-можливості	9
1.3 Бізнес-цілі та критерії успіху	10
1.4 Потреби клієнтів та ринку	11
1.5 Бізнес-ризики	11
2 КОНЦЕПЦІЇ РІШЕННЯ	13
2.1 Окреслення концепції	13
2.2 Головна функціональність	13
2.3 Припущення та залежності	14
3 РАМКИ ТА ОБМЕЖЕННЯ	16
3.1 Рамки первинного випуску	16
3.2 Рамки наступних випусків	17
3.3 Обмеження та винятки	18
4 БІЗНЕС-КОНТЕКСТ	19
4.1 Профілі зацікавлених сторін	19
4.2 Пріоритети проєкту	21
4.3 Робоче середовище	21
5 Серверна частина	23
5.1 Опис основних сутностей системи	23
5.2 Розробка UML діаграми прецедентів (Use Case Diagram)	24
5.3 Діаграма розгортання	25
5.4 Діаграма пакетів та архітектура програмної системи	26
5.5 Специфікація REST API	27
5.6 Опис прийнятих інженерних рішень	32
5.6.1 Аутентифікація	32
5.6.2 Обробник помилок	33
5.7 Структура проекту	36
6 ВЕБ-КЛІЄНТ	40
6.1 Опис інженерних рішень	40
6.2 Пояснення частин програмного коду	40
6.2.1 Авторизація	40
6.2.2 Обробка помилок	42
6.2.3 Локалізація сторінки та помилок	45
6.3 Діаграми	46
ВИСНОВКИ	50
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	51
ДОДАТОК А	52
ДОДАТОК Б	53
Б.1 Код файлу «CreateBrigadeCommand.cs»	53
Б.2 Код файлу «TokenService.cs»	56


ВСТУП

У сучасному світі швидке та ефективне надання допомоги постраждалим є критично важливим завданням для рятувальників і медичних працівників. Щорічно по всьому світу відбувається безліч надзвичайних ситуацій, аварій і медичних випадків, що потребують оперативного реагування. В таких умовах важливо мати доступ до актуальної інформації про стан постраждалих, щоб забезпечити своєчасне та кваліфіковане надання допомоги.
Наша система спрямована на вирішення цієї проблеми за допомогою браслетів з підтримкою NFC, які дозволяють зберігати та зчитувати важливі медичні дані та іншу інформацію про постраждалих. Використання таких браслетів забезпечує швидкий доступ до інформації про стан здоров'я постраждалих, що може бути критично важливим у випадках надзвичайних ситуацій. Браслети можуть містити інформацію про дії над постраждалими, що дозволяють рятувальникам і медичним працівникам приймати обґрунтовані рішення під час надання допомоги.
Метою даної курсової роботи є розробка програмної системи для відстеження медичних даних та іншої інформації про постраждалих за допомогою браслетів з підтримкою NFC. Ця система повинна включати в себе інструменти для збирання, збереження та аналізу даних, а також засоби для швидкого доступу до цієї інформації під час надання допомоги. Розробка такої системи сприятиме підвищенню ефективності роботи рятувальників і медичних працівників, покращенню якості надання допомоги постраждалим та зниженню ризиків, пов'язаних з неправильним діагностуванням або лікуванням.
У рамках цієї роботи буде проведено аналіз існуючих рішень на ринку, визначено основні вимоги до програмної системи, розроблено архітектуру та реалізовано відповідну програмну систему, що надасть повноцінний функціонал для організації та управління допомогою постраждалим. Крім того, буде здійснено тестування розробленої системи.
Таким чином, дана курсова робота має на меті внести вагомий внесок у розвиток інформаційних технологій у сфері надання допомоги постраждалим та сприяти підвищенню ефективності роботи рятувальних і медичних служб.

1 БІЗНЕС-ВИМОГИ
1.1 Передумови

Передумов для розробки програмної системи надання допомоги постраждалим з використанням браслетів з підтримкою NFC є чимало. Першою та найголовнішою причиною є вторгнення Росії на територію України. Війна супроводжується людськими втратами та пораненнями. І необхідність у наданні першої медичної допомоги постраждалим була, є і буде завжди актуальною. 
У війні задіяні усі людські ресурси. Це не тільки польові медики, а також пожежники, швидка медична допомога та інші. І тому є потреба у створені такого продукту, що буде корисних для усіх і покращить координацію між різними бригадами допомоги.
На меті розробки системи полягає забезпечення точної та достовірної інформацію про постраждалих і можливість введення детального обліку проведення заходів. Мається на увазі можливість фіксування дії, що були зроблені з постраждалим (накладання джгуту, проведення першої медичної допомоги, перев’язки, додатковий опис про постраждалого), а також додавання інформації про те, хто оглянув та надав допомогу. Завдяки цьому браслету у подальшому різні бригади зможуть передавати постраждалих із введеною інформацію, що було зроблено з цією людиною.

1.2 Бізнес-можливості

Є гарні приклади впровадження схожих систем у світі. Так, існує CarePredict Tempo - це браслет, призначений для відстеження активності та здоров'я користувачів. Він може виявляти падіння, відслідковувати зміни у режимі активності та навіть надсилати повідомлення доглядачам або медичним працівникам у разі виявлення проблем. 
VitalBand - це браслет для надання медичної допомоги, розроблений для вимірювання та моніторингу важливих показників здоров'я. Цей браслет може вимірювати кров'яний тиск, пульс, рівень кисню у крові та інші важливі показники, дозволяючи вчасно виявляти можливі проблеми зі здоров'ям.
Вищезгадані продукти хороші, але приклади браслетів, призначені для різних бригад не було знайдено, тим паче аналогів на ринку України. Тому є хороша можливість першими зайняти ринок з власним продуктом. 
Також є необхідність у монетизації, що надасть можливість підтримувати та покращувати продукт. Однією з підтримки програмної системи буде фінансування від держави або фондів, які підтримують інноваційні проекти у сфері медицини та допомоги постраждалим.
Ще надходження будуть йди від партнерства з медичними установами, що будуть використовувати продукт.
Ну і також надамо можливість кожній людині стати частиною покращення системи за рахунок пожертв та донатів.

1.3 Бізнес-цілі та критерії успіху

Бізнес-цілі (BO - Business Objectives):
BO-1: Збільшити обсяг продажів програмної системи на 50% протягом першого року.
BO-2: Забезпечити стабільну та надійну роботу програмної системи для всіх користувачів.
BO-3: Стати лідером у сфері надання допомоги постраждалим з використанням браслетів з підтримкою NFC.
BO-4: Створити ефективну мережу партнерів та отримати фінансування від держави.
Критерії успіху (SC - Success Criteria):
SC-1: Перевищення мети у встановленні програмної системи на ринку.
SC-2: Забезпечення стабільної роботи системи без жодних відмов протягом року.
SC-3: Отримання позитивних відгуків від не менше 80% користувачів програмної системи протягом першого року експлуатації.
SC-4: Зростання популярності використання браслетів серед різних медичних установ та бригад.
SC-5: Здійснення прибутку від використання програмної системи, що складає не менше 10% від загального обороту компанії протягом першого року її впровадження.

1.4 Потреби клієнтів та ринку

Потреби клієнтів та ринку наступні:
1. Ефективна надання допомоги: Клієнти, такі як медичні установи, екстрені служби та рятувальні організації, потребують зручних та ефективних засобів для надання швидкої допомоги постраждалим. Ваша система має задовольняти цю потребу, надаючи надійний спосіб ідентифікації пацієнтів та передачі важливої інформації про їх стан.
2. Потреба в швидкості та зручності. Система дозволяє оперативно надавати інформацію про постраждалого та надавати необхідну допомогу, що є важливим у випадках надзвичайних ситуацій.
3. Простота використання: Користувачі бажають мати простий та зрозумілий інтерфейс для використання системи. Важливо, щоб вона була легкою у використанні навіть для людей без спеціальної підготовки.
4. Інтеграція з іншими системами: програмна система повинна бути здатна інтегруватися з іншими медичними системами та обладнанням для обміну даними та спільної роботи.

1.5 Бізнес-ризики

1. Технічні проблеми: Можливість виникнення технічних проблем з браслетами, NFC технологією або програмним забезпеченням, що може призвести до перерв у роботі системи та негативно вплинути на її ефективність.
2. Конкуренція на ринку: Існує ризик з'явлення конкурентів, які пропонують подібні рішення з підтримкою NFC, що може призвести до втрати частки ринку та зниження прибутковості.
3. Доступність та безпека даних: Необхідність забезпечення безпеки та конфіденційності даних користувачів, що може вимагати великих витрат на забезпечення цієї безпеки та виконання нормативних вимог.
4. Юридичні обмеження: Ризик виникнення юридичних проблем або санкцій внаслідок порушення законодавства про захист персональних даних, медичну конфіденційність або інші правові вимоги.
5. Потенційні збитки здоров'ю: Необхідність забезпечення надійного та безпечного використання браслетів для користувачів, що може вимагати додаткових витрат на тестування та сертифікацію продукту.
6. Залежність від інфраструктури: Ризик залежності від інфраструктури NFC технології, електромережі та інших технічних систем, що може призвести до перерв у роботі системи у випадку недоступності цих інфраструктур.
7. Фінансові втрати: Можливість фінансових втрат внаслідок низької популярності або прийняття ринком конкурентних продуктів, що може вплинути на прибутковість проекту.

2 КОНЦЕПЦІЇ РІШЕННЯ
2.1 Окреслення концепції

Мета нашого продукту полягає в створенні системи для надання допомоги постраждалим, яка базується на використанні браслетів з підтримкою NFC. Наша система спрямована на забезпечення швидкого та ефективного виявлення та надання допомоги постраждалим, а також забезпечення зв'язку зі службами екстреної допомоги та медичними працівниками.
Продукт, який ми пропонуємо, це програмна система, що дозволяє відстежувати медичні дані та іншу інформацію про постраждалих за допомогою браслетів з підтримкою NFC. Ця інформація може бути використана для надання ефективної та швидкої допомоги у випадках надзвичайних ситуацій, аварій або медичних випадків.
Наш продукт буде корисним для рятувальників, медичних працівників та інших служб, які надають допомогу постраждалим. Він дозволить швидко виявляти постраждалих та отримувати доступ до необхідної інформації про їх стан для надання кваліфікованої допомоги.
Наша концепція базується на аналізі потреб рятувальників та медичних працівників у швидкому доступі до інформації про постраждалих, а також на використанні передових технологій, що дозволяють ефективно використовувати браслети з підтримкою NFC для цієї цілі.

2.2 Головна функціональність

Головна функціональність (MF – Major Feature): 
MF-1: Можливість вносити до браслету дані стосовно дії, що були надані постраждалому.
МF-2: Можливість перегляду інформації про постраждало, перегляд людини, що надавала допомогу а також дії зі сторони людей, що надавали допомогу на телефоні або сайті.
МF-3: Можливість вносити дані про постраждалого в базу.
МF-4: Можливість зчитування даних з браслету з використанням NFC.
МF-5: Можливість вимірювати кров'яний тиск, пульс, рівень кисню у крові та інші важливі показники, дозволяючи вчасно виявляти можливі проблеми зі здоров'ям.
MF-6: Збір та збереження даних з браслетів;
MF-7: Кластерний аналіз для для групування схожих дій, наданих рятівниками, що допоможе в ідентифікації паттернів та покращенні стратегій надання допомоги;
MF-8: Інтернаціоналізація та локалізація інтерфейсу (українська та англійська мови);

2.3 Припущення та залежності

Припущення:
1. Припущення щодо користувачів - припускається, що люди, які будуть використовувати браслет, мають мобільний застосунок для браслет для надання допомоги та додавання стану постраждалого до бази.
2. Доступ до Інтернету - доступ до мобільного зв'язку та інтернету буде стабільним для взаємодії з системою та надсилання необхідної інформації.
3. Уніфікованість програмної системи - припускається, що розроблена програмна система буде уніфікованою та сумісною з телефонами користувачів.
4. Регуляторні норми та стандарти - припускається, що програмна система буде відповідати всім необхідним регуляторним нормам та стандартам безпеки та якості в країнах, де вона буде запроваджена.
5. Доступність джерел енергії - припускається, що браслети матимуть джерело енергії для підзарядки.

Залежності:
1. Залежність від постачання продуктів харчування - система залежить від постійного та надійного постачання необхідних інгредієнтів та сировини для автоматів швидкого приготування їжі. Це включає постачання свіжих продуктів, інгредієнтів для приготування сублімованої їжі, а також додаткових матеріалів, таких як упаковка та посуд. Нестабільність у постачанні або недоліки в якості продуктів можуть негативно вплинути на функціонування системи та задоволення клієнтів. Тому важливо мати надійних постачальників та механізми контролю якості продукції.
2. Залежність від наявності електроенергії - залежність від того, що браслети матимуть доступ до достатньої кількості електроенергії для своєї роботи.
3. Розвиток мобільних та веб-додатків - залежність від розробки мобільних та веб-додатків для зручного використання браслетів.
4. Оновлення програмного забезпечення - потреба у регулярному оновленні програмного забезпечення та мобільних додатків для покращення функціональності та безпеки системи.

3 РАМКИ ТА ОБМЕЖЕННЯ
3.1 Рамки первинного випуску

Серверна частина програмної системи надаватиме користувачам наступний функціонал:
-	Створення облікових записів для користувачів (медичний персонал певної бригади).
-	Система авторизації та аутентифікації для безпечного доступу до системи.
-	Редагування та видалення записів про потерпілих працівників (для обмеженої групи користувачів).
-	Додавання інформації про потерпілого в базу.
-	Додавання, редагування та видалення інформації про бригаду, що користується системою.
-	Можливість надання інформації про потерпіло після зчитування інформації про нього з браслету.
-	Захист персональних даних користувачів.
-	Можливість створення резервного копіювання інформації для очільників бригад.
Клієнтська частина відповідатиме за наступне:
-	Веб-інтерфейс для користувачів.
-	Виключно для очільників бригад можливість редагування даних про зарєестрованих потерпілих та учасників бригад.
-	Зручний та простий інтерфейс для реєстрації та авторизації користувачів.
-	Можливість обрати англійський або український переклад інтерфейсу.
-	Відображення сповіщень про помилки системи.
Мобільний програмний застосунок матиме наступний функціонал:
-	Інтерфейс для реєстрації та авторизації користувачів.
-	Можливість отримати інформацію про браслет шляхом під’єдання до нього через NFC.
-	Отримання інформацію про потерпілих, зареєстрованих для певної бригади.
-	Можливість обрати англійський або український переклад інтерфейсу.
-	Відображення сповіщень про помилки системи.
У якості IoT буде використовуватися браслет з підтримкою NFC:
-	Отримання інформації про людину, що використовує браслет.
-	Можливість додавання інформації про потерпілого, що використовує браслет.

3.2 Рамки наступних випусків

-	Наступні випуски системи «Kolosok» будуть спрямовані на постійне вдосконалення та доповнення функціональності, щоб задовольнити зростаючі потреби користувачів та реагувати на ринкові вимоги. Планується реалізація таких функціональних можливостей у майбутніх випусках:
-	Додаткова аналітика та звітність: додаткові засоби для аналізу та візуалізації даних щодо ефективності надання допомоги постраждалим, звітність про ефективність браслету;
-	Автоматичні сповіщення у разі зменшення пульсу постраждалого нижче норми та у разі будь-яких інших критичних порушень.
-	Передбачено додавання інтерфейсів у веб застосунку для:
-	Відображення аналітики та звітності даних у формі таблиць, діаграм та статистик;
-	Інтерактивні сторінки для відображання стану пацієнта на різних ділянках його тіла.
-	Розширення збору та обробки даних на IoT пристрої. Зокрема передбачено додавання відслідковування наступних показників:
-	- Рівень кисню у крові;
-	- Кров’яний тиск.



3.3 Обмеження та винятки

-	Обмеження:
-	Технологічні обмеження - робота системи може бути обмежена технічними характеристиками браслетів та доступної мережі NFC. Залежно від моделі браслета, можуть виникати обмеження щодо дальності зчитування NFC, швидкості передачі даних та сумісності з іншими пристроями.
-	Безпека та надійність - неможливо гарантувати абсолютну безпеку та надійність системи. Існують ризики втрати даних, злому браслетів, несправності NFC-зв'язку або некоректної реакції на сигнали.
-	Законодавче регулювання - збір та обробка персональних даних повинна відповідати законодавству щодо конфіденційності та захисту персональних даних. Необхідно дотримуватися вимог щодо зберігання та обробки медичної інформації.
-	Винятки:
-	Спеціалізація на медичні цілі: Система спеціалізується на наданні медичної допомоги постраждалим, тому будь-які інші використання браслетів NFC або системи взагалі виключені.
-	Логістичні обмеження: Доступність системи може бути обмежена логістичними аспектами, такими як обмежена кількість доступних браслетів NFC, обмежена кількість медичних закладів, які підтримують систему тощо. 
-	Відповідальність користувачів: Користувачі повинні використовувати систему відповідально та дотримуватися правил користування, щоб уникнути можливих ризиків та проблем.

4 БІЗНЕС-КОНТЕКСТ
4.1 Профілі зацікавлених сторін

Таблиця 1.1 – Профілі зацікавлених сторін
Зацікавлені сторони	Основна цінність	Ставлення	Основні інтереси	Обмеження
Користувачі- постраждалі	Швидка та ефективна допомога в наданні медичної допомоги	Очікують високого рівня сервісу та підтримки у наданні необхідної допомоги	Отримання медичної допомоги в найкоротший термін, зручний та швидкий доступ до медичних послуг, можливість швидкого та ефективного спілкування з медичним персоналом	Можливість низького рівня доступу до інформації або технічних складнощів у використанні браслета












Таблиця 1.2 – Продовження таблиці
Медичний персонал та рятувальні служби	Покращення швидкості та ефективності надання медичної допомоги	Очікують надійної та зручної системи для надання допомоги постраждалим	Отримання швидкої інформації про стан постраждалого, можливість взаємодії з іншими рятувальними службами, ефективне використання ресурсів	Технічні обмеження або недостатність тренування персоналу для використання нової технології
Служби безпеки та регуляторні органи	Забезпечення безпеки та дотримання законодавства у наданні медичної допомоги	Очікують відповідності системи всім законодавчим вимогам та стандартам безпеки	Моніторинг та контроль за процесом надання медичної допомоги, можливість швидкого реагування на надзвичайні ситуації	Потреба у відповідних дозволах та регуляціях для використання системи







4.2 Пріоритети проєкту

Таблиця 2 – Пріоритети проєкту
Показник	Виконання (етапи)	Обмеження (граничні значення)	Ступінь свободи (діапазон можливостей)
Графік	Випуск MVP відбувається до 25.05	Випуск MVP відбувається не пізніше, ніж через 10 днів після дедлайну	MVP може вийти в реліз до 05.05
Функціонал	Для версії 1.0 має бути готово 70% функціоналу.	Завершеність функціоналу не є більш ніж на 30% нижчою за очікувану	Включення 65-70% важливих та пріоритетних функцій у версію 1.0
Якість	Система має проходити 100% тестів, бути стабільною в усіх сценаріях та не мати критичних помилок.	Ресурси та час для тестування	Можлива відсутність доступу до системи через проведення технічного обслуговування автоматів швидкого харчування
Персонал	Розмір команди: 1 розробник.	Розробляється 1 людиною.	Достатній рівень навичок для створення продукту.
Ціна	Бюджет 50 тисяч доларів. На версію 1.0 витратити 65% бюджету, на 1.1 – інші 35%.	Для версії 1.0 витрати не перевищують 3%, для 1.1 – 5%.	Перевищення бюджету до 10% прийнятне без розгляду керівництвом.


4.3 Робоче середовище

Робоче середовище проекту складається з наступних технологій для розробки своїх компонентів: C# і .NET 8 для серверної частини, ASP.NET Core 8.0 для API, DataGrip для бази даних, Entity Framework Core 8.0 для роботи з базою даних, AutoMapper, Swagger, NLog в якості бібліотек для серверної частини. TypeScript, Bootstrap 5 та Angular 16 для клієнтської частини, Kotlin і Android SDK 13 для мобільного застосунку, ESP32 та Wokwi, Servo-мотори, LED-панель, діодна лампа та динамік, а також Arduino IDE та Visual Studio Code, C++ 23  для IoT пристрою.
Вимоги щодо доступності, надійності, продуктивності та цілісності будуть визначені окремо для кожного компонента системи, з урахуванням вимог зацікавлених сторін та стандартів галузі. Розробка та тестування будуть здійснені з метою забезпечення високої якості та надійності продукту в робочому середовищі.
Ця технологічна інфраструктура забезпечує високу продуктивність та надійність системи. Однак важливо враховувати наступні фактори:
-	Географічний розподіл користувачів: Користувачі можуть бути розташовані у різних географічних регіонах.
-	Часові пояси: Зважаючи на різницю в часових поясах, необхідно
забезпечити зручний доступ до системи для користувачів із різних часових поясів.
-	Обробка та передача даних: Дані можуть генеруватися в різних
місцях та потребують передачі до центральної системи.
-	Надійність та доступність: Постійний доступ до системи може бути
вирішальним для бізнес-процесів користувачів.
-	Захист даних: Система повинна забезпечити контроль доступу та
захист особистих даних користувачів.

5 Серверна частина
5.1 Опис основних сутностей системи

ER-модель складається з 6 сутностей. Пройдемося по основним зв’язкам між ними:
-	«Контакт» - «Рятувальник» і «Контакт» - «Постраждалий» мають зв’язок один-до- одного;
-	«Постраждалий» - «Діагноз» мають зв’язок один-до-багатьох (у постраждалого може бути багато діагнозів, а діагноз є індивідуальним для кожного постраждалого);
-	«Постраждалий» - «Дія» мають зв’язок один-до-багатьох (у одного постраждалого може бути багато викликів, але дії можуть відноситися тільки до одного постраждалого;
-	«Бригада» - «Рятувальник» мають зв’язок один до багатьох (у однієї бригади може бути багато рятувальників, але рятувальник може бути тільки в одній);
-	«Рятувальник» - «Дія» мають зв’язок один-до-багатьох (один рятувальник може створити багато дій які відносяться до одного постраждалого).
З побудованих вище зв’зків можна побачити, що «Постраждалий» та «Рятувальник» мають багато спільних таблиць, завдяки чому вони можуть взаємодіяти між собою [2]. Нижче наведена ER-модель даних.


 
Рисунок 5.1 – ER-модель даних програмної системи надання допомоги постраждалим з використанням браслетів з підтримкою NFC


5.2 Розробка UML діаграми прецедентів (Use Case Diagram)

Після визначення основних сутностей системи слід описати їх можливості. Для цього зобразимо діаграми прецедентів програмної системи для моніторингу стану пацієнтів. 

 
Рисунок 5.2 – Діаграма прецедентів програмної системи надання допомоги постраждалим з використанням браслетів з підтримкою NFC


5.3 Діаграма розгортання

		Далі перейдемо до діаграми розгортання. Вона відображає усі необхідні файли для розгортання системи, а також зв’язок з базою даних (див. рис. 5.3).

 
Рисунок 5.3 – UML діаграма розгортання програмної системи надання допомоги постраждалим з використанням браслетів з підтримкою NFC

5.4 Діаграма пакетів та архітектура програмної системи

Було створено діаграму пакетів (Package Diagram), яка ілюструє різні рівні архітектури програмної системи (рис 4). Ця діаграма показує взаємозв’язки між пакетами та способи їх використання одне одним для виконання своїх завдань.

 
Рисунок 5.4 – Діаграма пакетів програмної системи надання допомоги постраждалим з використанням браслетів з підтримкою NFC

5.5 Специфікація REST API

Для обміну даними було обрано RESTful API — це архітектурний стиль інтерфейсу прикладної програми (API), який використовує запити HTTP для доступу та використання даних [6]. Щоб реалізувати це, для кожною основної сутності програмної системи було створено окремий контролер, у якому прописані усі маршрути для взаємодії. Нище наведені прикладі цих маршрутів та їх призначення.






Таблиця 5.1 – Специфікація REST API
Посилання	Метод	Призначення
GET	/api/v1/brigades	Отримати список всіх бригад з можливістю фільтрації 
POST	/api/v1/brigades	Створити нову бригаду за допомогою переданих даних в тілі запиту
PUT	/api/v1/brigades/{id}	Оновити інформацію про бригаду за допомогою переданих даних в тілі запиту
DELETE	/api/v1/brigades/{id}	Видалити бригаду за допомогою переданих даних у параметрах запиту
GET	/api/v1/brigades/{id}	Отримати інформацію про конкретну бригаду
GET	/api/v1/brigade-rescuers	Отримати список всіх рятувальників бригади з можливістю фільтрації
POST	/api/v1/brigade-rescuers	Створити нового рятувальника бригади за допомогою переданих даних в тілі запиту
GET	/api/v1/brigade-rescuers/{id}	Отримати інформацію про конкретного рятувальника бригади

Таблиця 5.1 – Продовження таблиці
GET	/api/v1/brigade-rescuers/{id}/qrcode	Отримати QR-код для рятувальника бригади
PUT	/api/v1/brigade-rescuers/{id}	Оновити інформацію про рятувальника бригади за допомогою переданих даних в тілі запиту
DELETE	/api/v1/brigade-rescuers/{id}	Видалити рятувальника бригади за допомогою переданих даних у параметрах запиту
GET	/api/v1/victim/{id:guid}/qrcode	Отримати QR-код для потерпілого за його ідентифікатором
GET	/api/v1/victim	Отримати список всіх потерпілих з можливістю фільтрації за допомогою параметрів запиту
GET	/api/v1/victim/{id:guid}	Отримати інформацію про конкретного потерпілого за його ідентифікатором
POST	/api/v1/victim	Створити нового потерпілого за допомогою переданих даних в тілі запиту
PUT	/api/v1/victim/{id:guid}	Оновити інформацію про потерпілого 


Таблиця 5.1 – Продовження таблиці
DELETE	/api/v1/victim/{id:guid}	Видалити потерпілого за його ідентифікатором
GET	/api/v1/diagnosis	Отримати список всіх діагнозів з можливістю фільтрації за допомогою параметрів запиту
GET	/api/v1/diagnosis/{id:guid}	Отримати інформацію про конкретний діагноз за його ідентифікатором
POST	/api/v1/diagnosis	Створити новий діагноз за допомогою переданих даних в тілі запиту
PUT	/api/v1/diagnosis/{id:guid}	Оновити інформацію про діагноз за допомогою переданих даних в тілі запиту
DELETE	/api/v1/diagnosis/{id:guid}	Видалити діагноз за його ідентифікатором
POST	/api/v1/auth/login	Автентифікація користувача. Приймає дані користувача для входу в систему і повертає JWT-токен для авторизації.









Таблиця 5.1 – Продовження таблиці
GET	/api/v1/auth/profile	Отримання профілю користувача. Вимагає наявності JWT-токена у заголовках запиту для доступу до профілю користувача.
POST	/api/v1/auth/refresh	Оновлення JWT-токена. Використовується для оновлення токена після закінчення його терміну дії.
POST	/api/v1/auth/register	Реєстрація нового користувача. Приймає дані нового користувача і створює обліковий запис в системі.
GET	/api/v1/backup	Отримати резервну копію бази даних у вигляді файлу
POST	/api/v1/backup	Відновити базу даних із резервної копії, яка передається в тілі запиту у вигляді масиву байтів
POST	/api/v1/localization/change	Зміна локалізації


5.6 Опис прийнятих інженерних рішень
5.6.1 Аутентифікація

	Аутентифікація відбувається за допомогою JWT-токенів. Повний код наведений в додатку А.
Щоб увійти у систему користувач повинен надіслати адресу своєї електронної пошти та пароль. Після цього вони валідуються на сервері із використанням методів та формується JWT-токен (Додаток Б.2). Код методу генерації токену користувача:

1 public string GenerateAccessToken(IEnumerable<Claim> claims)
2         {
3             var secretKey = new SymmetricSecurityKey("superSecretKey@345superSecretKey@345superSecretKey@345"u8.ToArray());
4             var signinCredentials = new SigningCredentials(secretKey, SecurityAlgorithms.HmacSha256);
5             var cleanedClaims = claims.Select(claim =>
6             {
7                 var type = claim.Type
8                     .Replace("http://schemas.xmlsoap.org/ws/2005/05/identity/claims/", "")
9                     .Replace("http://schemas.microsoft.com/ws/2008/06/identity/claims/", "");
10                 return new Claim(type, claim.Value);
11             });
12             
13             var tokeOptions = new JwtSecurityToken(
14                 issuer: "http://localhost:5000",
15                 audience: "http://localhost:5000",
16                 claims: cleanedClaims,
17                 expires: DateTime.Now.AddMinutes(60),
18                 signingCredentials: signinCredentials
19             );
20 
21             var tokenString = new JwtSecurityTokenHandler().WriteToken(tokeOptions);
22             return tokenString;
23         }

	5.6.2 Обробник помилок

Також можемо продемонструвати налаштування обробника винятків у програмі, який використовує мідлвару для обробки помилок веб-запитів:

1 private readonly ILogger<ExceptionHandlingMiddleware> _logger;
2 
3     public ExceptionHandlingMiddleware(ILogger<ExceptionHandlingMiddleware> logger) => _logger = logger;
4 
5     public async Task InvokeAsync(HttpContext context, RequestDelegate next)
6     {
7         try
8         {
9             await next(context);
10         }
11         catch (Exception e)
12         {
13             _logger.LogError(e, e.Message);
14 
15             await HandleExceptionAsync(context, e);
16         }
17     }
18 
19     private static async Task HandleExceptionAsync(HttpContext httpContext, Exception exception)
20     {
21         httpContext.Response.ContentType = "application/json";
22 
23         var statusCode = StatusCodes.Status500InternalServerError;
24         var errorMessage = "Internal Server Error";
25 
26         switch (exception)
27         {
28             case BadRequestException badRequestException:
29                 statusCode = StatusCodes.Status400BadRequest;
30                 errorMessage = badRequestException.Message;
31                 break;
32             case NotFoundException notFoundException:
33                 statusCode = StatusCodes.Status404NotFound;
34                 errorMessage = notFoundException.Message;
35                 break;
36             case ValidationException:
37                 statusCode = StatusCodes.Status400BadRequest;
38                 errorMessage = "Validation Error";
39                 break;
40         }
41 
42         httpContext.Response.StatusCode = statusCode;
43 
44         var errorResponse = new
45         {
46             errorMessage = errorMessage,
47             errors = exception is ValidationException validationException
48                 ? validationException.Errors.Select(error => new
49                 {
50                     property = error.Key,
51                     message = error.Value
52                 })
53                 : null
54         };
55 
56         await httpContext.Response.WriteAsync(JsonSerializer.Serialize(errorResponse, new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull }));
57     }

5.7 Структура проекту

Серверна частина проекту розроблена на мові програмування С# за допомогою фреймворку ASP.NET Core Web API. У якості СУБД використовується PostgreSQL. Також варто відзначити, що для зв’язку API із базою даних використовується Entity Framework Core 8.0.
	Серверна частина була побудована з використанням патерну проектування «Чиста архітектруа» та «ДДД-архітектура». Проект складається з п’яти проектів, що побудовані таким чином, щоб проект у майбутньому можна було масштабувати та змінювати.

 
Рисунок 5.5 – Архітектура проекту

	Доменна частина проекту складається з опису основних сутностей, помилок для сутностей, ресурсів перекладу.

 
Рисунок 5.6 – Файловий вигляд проекту Kolosok.Domain

В частині пов’язаній з інфраструктурою описано налаштування бази даних, основних репозиторій для взаємодії з базою, а також специфікації, що є реалізацією патерну «Специфікація».
Kolosol.Application містить опис усіх можливих дій над сутностями (приклад наведено в додатку В.1), контракти, інтерфейси для інших частин проекту, логіку валідації.

 
Рисунок 5.7 – Файловий вигляд проекту Kolosok.Applicatoin

В частині пов’язаній з інфраструктурою описано налаштування бази даних, основних репозиторій для взаємодії з базою, а також специфікації, що є реалізацією патерну «Специфікація».

 
Рисунок 5.8 – Файловий вигляд проекту Kolosok.Inftrustructure

Kolosok.Presentation представляє з себе налаштування Web API застосунку, опис взаємодії з іншими частинами проекту та опис усіх енпоінтів для взаємодії.

 
Рисунок 5.9 – Файловий вигляд проекту Kolosok.Presentation

Kolosok.Persistence містить бізнес-логіку, що не пов’язана з використанням бази даних, а також використовує стороні бібліотеки для роботи.

 
Рисунок 5.10 – Файловий вигляд проекту Kolosok.Persistence

Для проекту була використана саме така архітектура, щоб у подальшому серверна частина підгримувала масштабованість та дозволяла легко додавати нова сутності та фунціонал в уже існуючу систему.


6 ВЕБ-КЛІЄНТ
6.1 Опис інженерних рішень

Клієнтська частина проекту була розроблена на мові програмування TypeScript за допомогою фреймворку Angular 16. Створення самого проекту відбувалося у редакторі коду Jetbrains Web Storm 2023.2.5. Для авторизації та автентифікації користувачів було використано бібліотеку «auth0/angular-jwt» [1]. Angular для створення базових компонентів сайту.
Кореневою папкою є папка app. В ній знаходяться різні компоненти клієнтської частини (файлова структура проекту наведена в додатку А). Папка @core, що містить компоненти, які не мають логіки, але, повинні обов'язково бути завантаженими на етапі відкриття сайту; папка modules, в якій усі необхідні компоненти для взаємодії з базовими сутностями системи; папка models з інтерфейсами, що визначають сутності і папка shared у які містяться компоненти, що використовуватимуться у різних модулях. 
Для кожної сутності було створено окрему сторінку (приклад сторінки наведено в додатку В.1). На головних екранах цих сторінок є таблиця для перегляду даних та можливість взаємодіяти з ними.
Для	заповнення	даних	(редагування та додавання) були створені сторінки із відповідними формами.

6.2 Пояснення частин програмного коду
6.2.1 Авторизація


Після того як користувача було ідентифіковано він отримує токен доступу («access token»), який використовується для отримання захищених ресурсів. Цей токен поміщається в локальне сховище («local storage») і при кожному запиті дістається зі сховища та перевіряється. Перевірка  токену відбувається у класі «AuthGuard».

1  @Injectable({
2    providedIn: 'root'
3  })
4  export class AuthGuard implements CanActivate {
5    constructor(
6      private router: Router,
7      private jwtHelper: JwtHelperService,
8      private authService: AuthService
9    ) {}
10  
11    async canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {
12      const token = localStorage.getItem('jwt');
13  
14      if (token && !this.jwtHelper.isTokenExpired(token)) {
15        console.log(this.jwtHelper.decodeToken(token));
16        return true;
17      }
18  
19      const refreshToken = localStorage.getItem('refreshToken');
20      if (!refreshToken) {
21        this.router.navigate(['auth']);
22        return false;
23      }
24  
25      const isRefreshSuccess = await this.authService.tryRefreshingTokens(token!, refreshToken);
26      if (!isRefreshSuccess) {
27        this.router.navigate(['auth']);
28      }
29  
30      return isRefreshSuccess;
31    }
32	}

6.2.2 Обробка помилок

Обробка помилок була здійснена за допомогою MatSnackBar – класу бібліотеки Angular Material, що повідомляє користувачу про різні відповіді від серверної частини та помилки на стороні клієнта. Ниже наведений код сторінки авторизації користувача.

1  @Component({
2    selector: 'app-login',
3    templateUrl: './login.component.html',
4    styleUrls: ['./login.component.scss']
5  })
6  export class LoginComponent implements OnInit {
7    loginForm!: FormGroup;
8    hide = true;
9  
10    constructor(
11      private formBuilder: FormBuilder,
12      private router: Router,
13      private http: HttpClient,
14      private snackBar: MatSnackBar,
15      private translate: TranslateService
16    ) {}
17  
18    ngOnInit() {
19      this.loginForm = this.formBuilder.group({
20        email: ['', [Validators.required, Validators.email]],
21        password: ['', [Validators.required]]
22      });
23    }
24  
25    getErrorMessage(field: string) {
26      const control = this.loginForm.get(field);
27      if (control && control.errors) {
28        if (control.hasError('required')) {
29          return this.translate.instant('login.errors.required');
30        } else if (control.hasError('email')) {
31          return this.translate.instant('login.errors.email');
32        }
33      }
34      return '';
35    }
36  
37    togglePasswordVisibility() {
38      this.hide = !this.hide;
39    }
40  
41    onSubmit() {
42      if (this.loginForm.valid) {
43        const email = this.loginForm.get('email')?.value;
44        const password = this.loginForm.get('password')?.value;
45        const loginModel: LoginModel = { email, password };
46  
47        this.http.post<AuthenticatedResponse>("http://localhost:5000/api/v1/auth/login", loginModel, {
48          headers: new HttpHeaders({ "Content-Type": "application/json" })
49        }).subscribe({
50          next: (response: AuthenticatedResponse) => {
51            const token = response.token;
52            const refreshToken = response.refreshToken;
53            localStorage.setItem("jwt", token);
54            localStorage.setItem("refreshToken", refreshToken);
55            this.router.navigate(["/"]);
56          },
57          error: (response: HttpErrorResponse) => {
58              this.snackBar.open(response.error.errorMessage, 'Close', {
59                panelClass: ['custom-snackbar', 'snackbar-success'],
60                duration: 3000,
61              });
62          }
63        });
64      }
67    }
68	}


6.2.3 Локалізація сторінки та помилок


Для локалізації клієнтської частини було використано бібліотеку ngx-translate [3], що надає доступ до використання TranslateService – класу для роботи з перекладами. Для локалізації було створено два файли формату json та папку i18n. У подальшому сервіс перекладу буде брати в залежності від обраної локалізації її відповідні зміні та демонструвати на сторінках.
Для того, щоб отримувати з серверної частини відповіді про помилки або іншу інформацію з використанням відповідної мови було створено перехоплювач, що для кожного запиту додаватиме значення для поля Accept-Language.

1  @Injectable()
2  export class LanguageInterceptor implements HttpInterceptor {
3  
4    constructor(private translate: TranslateService) {}
5  
6    intercept(request: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {
7      const currentLang = this.translate.currentLang || this.translate.defaultLang;
8      const language = currentLang === 'ua' ? 'uk-UA' : 'en-US';
9      const modifiedRequest = request.clone({
10        setHeaders: { 'Accept-Language': language }
11      });
12      return next.handle(modifiedRequest);
13    }
14  }

6.3 Діаграми


Для клієнтської частини було створено діаграму прецедентів (рис. 1). Вона надає користувачам доступ до функціоналу серверної частини. Цядіаграма також містить 3 актора і функціональні можливості серверної частини.

 
Рисунок 6.1 – Діаграма прецедентів клієнтської частини програмної програмної системи надання допомоги постраждалим з використанням браслетів з підтримкою NFC

Також було створено діаграму компонентів (рис. 2). Вона надає можливість візуалізувати, як компоненти взаємодіють між собою в межах системи. Крім того, ця діаграма є корисною в управлінні модульністю системи та складністю її структури.

 
Рисунок 6.2 – Діаграма компонентів клієнтської частини програмної програмної системи надання допомоги постраждалим з використанням браслетів з підтримкою NFC

Діаграма пакетів для клієнтської частини містить 2 головних пакети:
Modules і Core (рис. 3). Всередині цих пакетів знаходяться інші пакети, що взаємодіють одне з одним.

 
Рисунок 6.3 – Діаграма пакетів клієнтської частини програмної програмної системи надання допомоги постраждалим з використанням браслетів з підтримкою NFC

До того ж, було створено діаграму станів (рис. 4). Ця діаграма показує увесь процес взаємодії користувача із клієнтською частиною. Вона надає можливість зрозуміти які дії необхідно виконати для отримання певного результату.

 
Рисунок 6.4 – Діаграма станів клієнтської частини програмної програмної системи надання допомоги постраждалим з використанням браслетів з підтримкою NFC

У подальшому ці діаграми були використані для побудови клієнтської частини. 

ВИСНОВКИ

В результаті виконання курсової роботи було досягнуто основної мети – створено програмну систему для надання допомоги постраждалим за допомогою браслетів з підтримкою NFC. Загалом розроблена система надає її користувачам наступні можливості: авторизація та створення нових акаунтів для рятувальників; збирання, збереження та редагування даних про постраждалих; зчитування даних з браслетів з підтримкою NFC; зберігання даних про дії, які були надані постраждалим; можливість створення резервної копії даних та керування користувача системи.
Для створення програмної системи було задіяно чимало технологій. Для розробки серверної частини було використано платформу .NET 8, фреймворк ASP.NET Core 8.0, ORM Entity Framework Core 8.0, систему авторизації та аутентифікації ASP.NET Core Identity, а також СУБД PostgreSQL. Клієнтську частину було створено за допомогою фреймворку Angular 16. Для браслетів (ІоТ пристрій) використовувався мікроконтролер ESP32.
Програмна система має потенціал для подальшого розвитку та вдосконалення, що показало функціональне тестування [7]. Зокрема, можливо розширити функціонал системи за рахунок інтеграції з системами аналітики та прогнозування, розробити мобільні застосунки для рятувальників та медичних працівників, а також впровадити технології штучного інтелекту для оптимізації процесів надання допомоги.
Таким чином, дана курсова робота має на меті внести вагомий внесок у розвиток інформаційних технологій у сфері надання допомоги постраждалим та сприяти підвищенню ефективності роботи рятувальних і медичних служб.

ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ

1. Entity Framework Core Series. URL: https://code-maze.com/entity-framework-core-series/ (дата звернення: 02.06.2024). 
2. SQL Server Joins. URL: https://www.sqlservertutorial.net/sql-server-basics/sql-server-joins/ (дата звернення: 02.06.2024).
3. Вступ до REST API — RESTful вебсервіси. URL: https://robotdreams.cc/uk/blog/466-vstup-do-rest-api-restful-vebservisi
4. JWT Authentication in ASP.NET Core Web API:  https://code-maze.com/authentication-aspnetcore-jwt-1/ (дата звернення: 02.06.2024). 
5. How to translate your Angular app with ngx-translate. URL: https://www.codeandweb.com/babeledit/tutorials/how-to-translate-your-angular-app-with-ngx-translate (дата звернення: 02.06.2024).
6. GitHub - NureDzabakhidzeDavyd/apzkr-pzpi-21-3-dzabakhidze-davyd. GitHub. URL: https://github.com/NureDzabakhidzeDavyd/apzkr-pzpi-21-3-dzabakhidze-davyd (дата звернення: 02.06.2024).
7. ПЗПІ-21-3 | АПЗ | Дзабахідзе Давид | Демонстрація курсової роботи. URL: https://www.youtube.com/watch?v=KGikNArfy8I (дата звернення: 09.06.2024).

ДОДАТОК А
Результат перевірки на плагіат
 

ДОДАТОК Б
Програмний код серверної частини

Б.1 Код файлу «CreateBrigadeCommand.cs»
  1  public class CreateBrigadeCommand : IRequest<BrigadeResponse>
  2  {
  3      public string Name { get; set; }
  4      public string Description { get; set; }
  5          
  6      public IList<Guid> BrigadeRescuers { get; set; }
  7  }
  8  
  9  public class CreateBrigadeCommandHandler : IRequestHandler<CreateBrigadeCommand, BrigadeResponse>
  10  {
  11      private readonly IUnitOfWork _unitOfWork;
  12      private readonly IMapper _mapper;
  13  
  14      public CreateBrigadeCommandHandler(IMapper mapper, IUnitOfWork unitOfWork)
  15      {
  16          _mapper = mapper;
  17          _unitOfWork = unitOfWork;
  18      }
  19  
  20      public async Task<BrigadeResponse> Handle(CreateBrigadeCommand request, CancellationToken cancellationToken)
  21      {
  22          var brigade = _mapper.Map<Domain.Entities.Brigade>(request);
  23          var newBrigade = await _unitOfWork.BrigadeRepository.CreateAsync(brigade);
  24          
  25          if (request.BrigadeRescuers.Any())
  26          {
  27              foreach (var rescuerId in request.BrigadeRescuers)
  28              {
  29                  if(!await _unitOfWork.BrigadeRescuerRepository.ExistAsync(b => b.Id == rescuerId))
  30                  {
  31                      throw new BrigadeRescuerNotFoundException(rescuerId);
  32                  }
  33  
  34                  await _unitOfWork.BrigadeRescuerRepository.UpdatePropertiesAsync(b => b.Id == rescuerId,
  35                      (b => b.BrigadeId, newBrigade.Id));
  36              }
  37          }
  38          
  39          await _unitOfWork.SaveChangesAsync();
  40          var response = _mapper.Map<BrigadeResponse>(newBrigade);
  41          return response;
  42      }
  43  }
  44  
  45  public class CreateBrigadeCommandValidator : AbstractValidator<CreateBrigadeCommand>
  46  {
  47      public CreateBrigadeCommandValidator()
  48      {
  49          RuleFor(p => p.Name)
  50              .NotEmpty().WithMessage("{PropertyName} is required.")
  51              .NotNull()
  52              .MaximumLength(50).WithMessage("{PropertyName} must not exceed 50 characters.");
  53          
  54          RuleFor(p => p.Description)
  55              .NotEmpty().WithMessage("{PropertyName} is required.")
  56              .NotNull()
  57              .MaximumLength(500).WithMessage("{PropertyName} must not exceed 500 characters.");
  58      }
  59  }

Б.2 Код файлу «TokenService.cs» 

  1  {
  2      public class TokenService : ITokenService
  3      {
  4          public string GenerateAccessToken(IEnumerable<Claim> claims)
  5          {
  6              var secretKey = new SymmetricSecurityKey("superSecretKey@345superSecretKey@345superSecretKey@345"u8.ToArray());
  7              var signinCredentials = new SigningCredentials(secretKey, SecurityAlgorithms.HmacSha256);
  8              var cleanedClaims = claims.Select(claim =>
  9              {
  10                  var type = claim.Type
  11                      .Replace("http://schemas.xmlsoap.org/ws/2005/05/identity/claims/", "")
  12                      .Replace("http://schemas.microsoft.com/ws/2008/06/identity/claims/", "");
  13                  return new Claim(type, claim.Value);
  14              });
  15              
  16              var tokeOptions = new JwtSecurityToken(
  17                  issuer: "http://localhost:5000",
  18                  audience: "http://localhost:5000",
  19                  claims: cleanedClaims,
  20                  expires: DateTime.Now.AddMinutes(60),
  21                  signingCredentials: signinCredentials
  22              );
  23  
  24              var tokenString = new JwtSecurityTokenHandler().WriteToken(tokeOptions);
  25              return tokenString;
  26          }
  27  
  28          public string GenerateRefreshToken()
  29          {
  30              var randomNumber = new byte[32];
  31              using var rng = RandomNumberGenerator.Create();
  32              rng.GetBytes(randomNumber);
  33              return Convert.ToBase64String(randomNumber);
  34          }
  35  
  36          public ClaimsPrincipal GetPrincipalFromExpiredToken(string token)
  37          {
  38              var tokenValidationParameters = new TokenValidationParameters
  39              {
  40                  ValidateAudience = false,
  41                  ValidateIssuer = false,
  42                  ValidateIssuerSigningKey = true,
  43                  IssuerSigningKey = new SymmetricSecurityKey("superSecretKey@345superSecretKey@345superSecretKey@345"u8.ToArray()),
  44                  ValidateLifetime = false
  45              };
  46  
  47              var tokenHandler = new JwtSecurityTokenHandler();
  48              var principal = tokenHandler.ValidateToken(token, tokenValidationParameters, out var securityToken);
  49              if (securityToken is not JwtSecurityToken jwtSecurityToken || !jwtSecurityToken.Header.Alg.Equals(SecurityAlgorithms.HmacSha256, StringComparison.InvariantCultureIgnoreCase))
  50                  throw new SecurityTokenException("Invalid token");
  51  
  52              return principal;
  53          }
  54      }
  55  }

ДОДАТОК В
Програмний код клієнтської частини

В.1 Код файлу «brigade-rescuers-list.component.html» 

  1  @Component({
  2    selector: 'brigade-rescuers-list',
  3    templateUrl: './brigade-rescuers-list.component.html',
  4    styleUrls: ['./brigade-rescuers-list.component.scss']
  5  })
  6  export class BrigadeRescuersListComponent implements OnInit {
  7    public displayedColumns: string[] = ['firstName', 'lastName', 'middleName', 'phone', 'email', 'address'];
  8  
  9    dataSource = new MatTableDataSource<BrigadeRescuer>();
  10    public totalRecords: number = this.dataSource.data.length;
  11    public pageSize = 10;
  12    public currentPage = 1;
  13  
  14    constructor(private rescuerService: BrigadeRescuerService, private router: Router, private dialog: MatDialog) {}
  15  
  16    ngOnInit(): void {
  17      this.loadBrigadeRescuers();
  18    }
  19  
  20    loadBrigadeRescuers(): void {
  21      this.rescuerService.getAll(this.currentPage, this.pageSize).subscribe(
  22        (rescuers: BrigadeRescuer[]) => {
  23  
  24          this.dataSource.data = rescuers;
  25          this.dataSource.sortingDataAccessor = (object: BrigadeRescuer, property: string) => {
  26            switch (property) {
  27              case "firstName":
  28                return object.contact.firstName;
  29              case "lastName":
  30                return object.contact.lastName;
  31              case "middleName":
  32                return object.contact.middleName;
  33              case "phone":
  34                return object.contact.phone;
  35              case "email":
  36                return object.contact.email;
  37              case "address":
  38                return object.contact.address;
  39              default:
  40                return object.contact.firstName;
  41            }
  42          };
  43        }
  44      );
  45    }
  46  
  47    deleteBrigadeRescuer(id: string): void {
  48      this.rescuerService.delete(id).subscribe(
  49        () => {
  50          this.loadBrigadeRescuers();
  51        },
  52        (error) => {
  53          console.error('Помилка видалення бригади:', error);
  54        }
  55      );
  56    }
  57  
  58    public deleteConfirmation(id: string): void {
  59      const dialogRef = this.dialog.open(ConfirmDeleteModalComponent, {
  60        width: '250px',
  61      });
  62  
  63      dialogRef.afterClosed().subscribe((result) => {
  64        if (result) {
  65          this.deleteBrigadeRescuer(id);
  66        }
  67      });
  68    }
  69  
  70    openDetails(brigadeId: string): void {
  71      // Assuming 'brigade-details' is the route for displaying brigade details
  72      this.router.navigate(['brigade-rescuers', brigadeId]);
  73    }
  74  
  75    onPageChange(page: number): void {
  76      this.currentPage = page;
  77      this.loadBrigadeRescuers();
  78    }
  79  
  80    openEdit(brigadeId: string) {
  81      this.router.navigate(['brigade-rescuers', brigadeId, 'edit']);
  82    }
  83  
  84    createNewBrigade(): void {
  85      this.router.navigate(['brigade-rescuers/create']);
  86    }
  87  }